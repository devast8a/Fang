import chalk from "chalk";
import * as fs from "fs";
import * as nearley from "nearley";
import 'source-map-support/register';
import { CallStatic, Class, Function, Scope, Thing, Variable, Stmt, Type, Tag, Expr, GetField, VariableFlags } from './ast';
import TargetCGcc from './codegen';
import grammar from "./grammar";
import { Tag as AstTag } from './post';
import { TypeChecker } from './type_check';
import Polymorpher from './polymorph';
import { Analyzer } from './analysis';

// Create a Parser object from our grammar.
const compiled = nearley.Grammar.fromCompiled(grammar);

function first(data: any){return data[0];}

// Simplify our AST a bit. If our rule only has one thing it matches on,
//  don't create a new deeper set of nodes.
//
// Eg. Typically `foo -> bar bar; bar -> "A"`
//  would generate the ast [["A"], ["A"]] for the input "AA".
//  We decided to remove the extra layer of indirection, instead generating ["A", "A"]
for(const rule of compiled.rules){
    if(rule.name.indexOf('$') !== -1) {
        // Post-processors generated by Nearley rules.
        // We need to be careful about applying it to Nearley generated rules,
        //  otherwise we could break them - in particular rules that compact repetition into arrays

        // Macro calls
        if(/\$macrocall\$\d+$/.test(rule.name)){
            if(rule.postprocess !== undefined){
                // Already has a post-processor assigned
            } else if(rule.symbols.length === 1) {
                rule.postprocess = first;
            }
        }
    } else if(rule.postprocess !== undefined){
        // Already has a post-processor assigned
    } else if(rule.symbols.length === 1) {
        rule.postprocess = first;
    }
}

class Source {
    public constructor(path: string, content: string){
        this.path = path;
        this.content = content;
    }

    public static async fromFile(path: string){
        const content = await fs.promises.readFile(path, "utf8");
        return new Source(path, content);
    }

    public path: string;
    public content: string;
}

class Parse {
    public execute(compiler: Compiler){
        // TODO: Properly load source
        const source = (compiler as any).source as Source;

        // Parse
        console.time("parsing");
        const parser = new nearley.Parser(compiled);
        parser.feed(source.content);
        console.timeEnd("parsing");

        if(parser.results.length > 1){
            console.error("! AMBIGUOUS GRAMMAR !");
            console.log(JSON.stringify(parser.results[0], null, 4));
            console.log(JSON.stringify(parser.results[1], null, 4));
            console.log(parser.results.length);

            // TODO: Remove this kludge
            throw new Error();
        }

        return parser.results[0];
    }
}

class AstGeneration {
    public execute(compiler: Compiler){
        const parse = new Parse();
        const results = parse.execute(compiler);

        // Ast Generation
        console.time("ast-generation");
        for(const node of results){
            compiler.parse(node, compiler.scope);
            // this.parse(node, this.scope);
        }
        console.timeEnd("ast-generation");

        // TODO: Remove hack to avoid outputting compiler defined functions
        compiler.scope.types.delete("none");
        compiler.scope.types.delete("str");
        compiler.scope.types.delete("int");
        compiler.scope.types.delete("writeLn");
        compiler.scope.types.delete("$infix+");
        compiler.scope.functions.delete("writeLn");
        compiler.scope.functions.delete("$infix+");
    }
}

class TypeCheck {
    public execute(compiler: Compiler){
        const astGeneration = new AstGeneration();
        const scope = astGeneration.execute(compiler);

        // Type check
        console.time("type-checking");
        const checker = new TypeChecker(compiler);
        for(const type of compiler.scope.types.values()){
            checker.check(type);
            //type.checkTypes(this);
        }
        console.timeEnd("type-checking");

    }
}

class Analyze {
    public execute(compiler: Compiler){
        const typeCheck = new TypeCheck();
        typeCheck.execute(compiler);

        // Analysis
        console.time("analysis");
        const analyser = new Analyzer();
        for(const type of compiler.scope.types.values()){
            analyser.check(type);
        }
        console.timeEnd("analysis");

    }
}

export class Monomorphize {
    public execute(compiler: Compiler){
        const analyze = new Analyze();
        analyze.execute(compiler);

        // Monomorphize
        console.time("monomorphize");
        const polymorpher = new Polymorpher(compiler.scope);
        for(const type of compiler.scope.types.values()){
            let morphed = polymorpher.polymorph(type);

            if(morphed.tag === Tag.Function){
                compiler.scope.types.set(morphed.name, morphed);
                compiler.scope.functions.set(morphed.name, morphed);
            }
        }
        console.timeEnd("monomorphize");

    }
}

class Output {
    public execute(compiler: Compiler){
        const monomorphize = new Monomorphize();
        monomorphize.execute(compiler);

        // Code-gen
        console.time("code-gen");
        if(compiler.errors.length === 0){
            const target = new TargetCGcc();

            for(const thing of (compiler.scope as any).classes.values()){
                target.compileClass(thing);
            }

            for(const func of Array.from(compiler.scope.functions.values())){
                target.declareFunction(func);
            }

            for(const func of Array.from(compiler.scope.functions.values())){
                target.compileFunction(func);
            }

            const output = target.output.join("");
            fs.writeFileSync("build/test.c", output);
        }
        console.timeEnd("code-gen");

    }
}


export class Compiler {
    public report(error: any) {
        throw new Error('Method not implemented.');
    }

    // TODO: Refactor this out
    public readonly scope: Scope;
    public readonly types: {
        string: Type,
        int: Type,
    };

    constructor(){
        // TODO: Support binding to target within the language itself
        // TODO: Use the actual name of the module
        const scope = this.scope = new Scope('Ftest_');

        const str = new Class("", "str", "char*", scope);
        const int = new Class("", "int", "int", scope);
        const none = new Class("", "none", "void", scope);

        scope.types.set("none", none);
        scope.types.set("str", str);
        scope.types.set("int", int);

        const f = new Function("", "writeLn", "writeLn", scope);
        f.returnType = none;
        (f as any).ffi_name = "printf";
        f.parameters.push(new Variable("", "", str, VariableFlags.None, ""));
        f.parameters.push(new Variable("", "", int, VariableFlags.None, ""));

        scope.declareFunction(f);

        scope.functions.set("$infix+", new Function("", "$infix+", "$infix+", scope));

        this.types = {
            string: str,
            int: int,
        };
    }

    public callsToMonomorphize = new Array<CallStatic>();   // Used in monomorphize step

    // TODO: Refactor
    public errors = new Array<any>();

    public parse(node: any, scope: Scope): Thing{
        switch(node.tag){
            // Run the AST builders on each Nearley node
            // See: ast_builders for the code that is actually run to build each AST Node
            // See: post for the code that wraps Nearley nodes with AST builders (in particular post.builder)
            case AstTag.NODE: {
                return node.builder(node.data, this, scope);
            }

            // Ignore whitespace, this whitespace comes primarily from the whitespace between elements in statement lists.
            //  It should be removed much earlier in parsing, but we're waiting until we have a better idea how everything
            //  will pan out.
            case AstTag.WHITESPACE: {
                // TODO: Avoid subverting type system
                return undefined as any;
            }

            default: {
                throw new Error(`Unknown node tag: ${node.tag}`);
            }
        }
    }

    public compile(source: Source){
        (this as any).source = source;

        const output = new Output();
        output.execute(this);

        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        
        if(this.errors.length > 0){
            // Display errors
            while(this.errors.length > 0){
                let {format, args, highlight} = this.errors.pop();

                let color = true;

                // Find the most likely word
                //const incorrect = args[1];
                //if(incorrect !== undefined){
                //    let types = Array.from(compiler.types.values())
                //        .map(type => ({name: type.name, distance: levenshteinDistance(type.name, incorrect)}))
                //        .sort((a, b) => a.distance - b.distance);

                //    args.push(types[0].name);
                //}
                args.push("???");

                // Color each of the arguments
                if(color){
                    args = args.map((x:string) => chalk.whiteBright(x));
                }

                const target = highlight[0];

                // First line components
                let banner    = "!";
                let path      = source.path;
                let line      = target.line;
                let col       = target.col;
                let message   = format.replace(/\$(\d+)/g, (_: any, index: number)=> `'${args[index]}'`);

                // Color each of the first line components
                if(color){
                    banner  = chalk.bgRedBright.whiteBright(banner);
                    path    = chalk.blueBright(path);
                    line    = chalk.greenBright(line);
                    col     = chalk.greenBright(col);
                }

                // First line
                console.log(`${banner} ${message} (${path}:${line}:${col})`);
                console.log();

                // Context...
                const begin = target.col - 1;
                const end = begin + target.text.length;
                const src = source.content.split(/(\r\n|\r|\n)/g);

                let content = src[target.line * 2 - 2]
                content = content.slice(0, begin) +
                    chalk.redBright(content.slice(begin, end)) +
                    content.slice(end);

                console.log(target.line + ":     " + content);

                if(this.errors.length > 0){
                    console.log();
                    console.log();
                    console.log();
                }
            }

            process.exit(1);
        }
    }
};

async function main(){
    console.group("Compiling...");
    const compiler = new Compiler();
    const source = await Source.fromFile(process.argv[2]);
    compiler.compile(source);
    console.groupEnd();
}

main().catch((e) => {
    console.log(e);
    process.exit(1);
});

//const path = process.argv[2];
//const content = fs.readFileSync(path, "utf8");
//const source = new Source(path, content);

function levenshteinDistance(a: string, b: string){
    return levenshteinDistance_(a, b, a.length, b.length);
}

function levenshteinDistance_(a: string, b: string, i: number, j: number): number {
    // TODO: Optimize this function
    if(Math.min(i, j) === 0){
        return Math.max(i, j);
    }

    return Math.min(
        levenshteinDistance_(a, b, i - 1, j) + 1,
        levenshteinDistance_(a, b, i, j - 1) + 1,
        levenshteinDistance_(a, b, i - 1, j - 1) + (a.charAt(i) === b.charAt(j) ? 0 : 1),
    );
}