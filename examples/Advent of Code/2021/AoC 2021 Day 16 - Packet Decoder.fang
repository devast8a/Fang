##DEBUG_PRINT_AST

fn decodeHexDigit(code: u32) {
    # This function assumes that the input is a hex digit.
    #   ie. 0 - 9, A - F, or a - f
    #
    # The function exploits how ASCII characters are encoded
    #     Upper case letters are encoded as 0b0100_0001 + LETTER
    #     Lower case letters are encoded as 0b0110_0001 + LETTER
    #                Numbers are encoded as 0b0011_0000 + NUMBER
    val isNumber = (code & 0b0100_0000) == 0
    val value    = (code & 0x0F)
    
    if isNumber {
        return value
    } else {
        return value + 9
    }
}

fn decodeHex(s: str) {
    val list = List{}

    mut i = 0
    while i < s.size {
        list.push(
            decodeHexDigit(s.getCode(i    ))<<4 |
            decodeHexDigit(s.getCode(i + 1))
        )
        i = i + 2
    }

    return list
}

struct Stream {
    val stream: List
    
    val position = 0

    fn read(self, bits: u32) {
        if (bits > 8) {
            return self.read(8)<<8 | self.read(bits - 8)
        }

        val byte = self.position // 8
        val bit  = self.position % 8
        self.position = self.position + bits

        val value = (self.stream[byte]<<bit & 0xFF) |
            (self.stream[byte + 1] >> 8-bit)

        return (value >> 8-bits) & (1<<bits - 1)
    }

    fn fromHex(str: str) {
        return Stream{decodeHex(str)}
    }
}

fn decode(packet: Stream) {
    val version = packet.read(3)
    val type    = packet.read(3)

    # Decode a 'literal' value
    if type == 0b100 {
        mut value = 0
        mut next  = true

        while next {
            next  = packet.read(1) == 1
            value = packet.read(4) | value<<4
        }

        return value
    }

    # Decode subpackets
    val subpackets = List{}
    if packet.read(1) == 0 {
        val end = packet.read(15) + packet.position

        while packet.position < end {
            subpackets.push(decode(packet))
        }
    } else {
        val count = packet.read(11)

        while count > 0 {
            count = count - 1
            subpackets.push(decode(packet))
        }
    }

    # Evaluate the packet
    match type {
        case 0 => subpackets.reduce(infix+)
        case 1 => subpackets.reduce(infix*)
        case 2 => subpackets.reduce(Math.min)
        case 3 => subpackets.reduce(Math.max)
        case 5 => subpackets[0]  < subpackets[1]
        case 6 => subpackets[0]  > subpackets[1]
        case 7 => subpackets[0] == subpackets[1]
    }
}

return decode(Stream.fromHex('9C0141080250320F1802104A08'))