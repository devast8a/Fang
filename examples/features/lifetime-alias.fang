struct T {}

fn mutateBoth(mut foo: T, mut bar: T) -> void {
}

# The 'alias' attribute adds a constraint to callers of `ourCustomFn`
#   Whatever is passed into `ref` becomes an alias of `target` during lifetime checking.
fn ourCustomFn(ref: T, target: T) -> void
    #alias(ref, target)
{
}

fn main() -> u32 {
    mut foo = T{}
    mut bar = T{}

    # This is allowed both `foo` and `bar` are distinct object.
    mutateBoth(foo, bar)

    ourCustomFn(foo, bar)

    # This is an error now because `ourCustomFn` declared that `foo` is an alias of `bar`
    #   and we are not allowed to have two or more mutable references to the same value.
    mutateBoth(foo, bar)
}