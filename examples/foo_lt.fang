class T {}

class Ref
    generic<T>
{
}





fn simple1() {
    mut foo = T{}
}
# foo: Alive | foo: {}



fn simple2() {
    mut foo = T{}
    consume(move(foo))
}
# foo: Dead | foo: {}



fn simple3() {
    mut foo = T{}
    foo = T{}
}
# Fang detects foo is always alive on the second assignment and destroys the previous value
# foo: Alive | foo: {}



fn simple4() {
    mut foo = T{}
    consume(move(foo))
    foo = T{}
}
# Fang detects foo is always dead on the second assignment and doesn't destroy anything
# foo: Alive | foo: {}



fn simply5() {
    mut foo: T
    foo = T{}
}
# Delaying assignment works as well
# foo: Alive | foo: {}



fn branches1() {
    mut foo = T{}

    if (condition) {
        consume(move(foo))
        foo = T{}
    }
}
# Works with branches, assuming the lifetime of the variable remains the same on both sides of the branch.
# foo: Alive | foo: {}



fn branches2() {
    mut foo = T{}

    if (condition) {
        consume(move(foo))
    } else {
        consume(move(foo))
    }
}
# foo: Dead | foo: {}



fn branches3() {
    val foo: T

    if (condition) {
        foo = T{}
    } else {
        foo = T{}
    }
}
# Delaying assignment works as well
# foo: Alive | foo: {}



fn branches4() {
    val foo = T{}
    val bar = T{}
    val ref = Ref{foo}

    if (condition) {
        ref = Ref{bar}
    }
}
# foo: Alive, bar: Alive, ref: Alive | foo: {}, bar: {}, ref: {foo, bar}



fn branches5() {
    val foo = T{}
    val bar = T{}
    val ref = Ref{foo}

    if (condition) {
        ref = Ref{bar}
    }
}



fn loop1() {
    mut foo = T{}

    while (condition) {
        consume(move(foo))
        foo = T{}
    }
}



fn dynamic1() {
    mut foo = T{}

    if (condition) {
        consume(move(foo))
    }
}
# Fang can detect if a variable is Alive on one side of a branch and Dead on another.
# In this case it is marked as having dynamic lifetime.
# 
# We could add a flag to track this like Rust - or force the developer to destroy foo in the other branch,
# I haven't decided what we will end up doing
# foo: Dynamic | foo: {}



fn references1() {
    mut foo = T{}
    mut ref = Ref{foo}
}
# Tracks references too
# foo: Alive, ref: Alive | foo: {}, ref: {foo}



fn references2() {
    mut foo = T{}
    mut ref = Ref{foo}

    consume(move(foo))
}
# foo: Dead, ref: Dead | foo: {}, ref: {}



fn errors1() {
    val foo: T
    # consume(move(foo))    # Compile error. (foo has not been assigned a value)
}



fn errors2() {
    val foo = T{}
    consume(move(foo))
    # consume(move(foo))    # Compile error. (The value of foo is no longer available)
}



fn errors3() {
    val foo = T{}

    if (condition) {
        consume(move(foo))
    }

    # consume(move(foo))    # Compiler error. (The value of foo may no longer be available)
}



fn check() {
    mut foo = T{}
    mut bar = T{}
    mut ref = Ref{foo}

    loan_loan(foo, foo)
    loan_loan(foo, bar)
    # loan_mutate(foo, foo)
    loan_mutate(foo, bar)
    # mutate_mutate(foo, foo)
    mutate_mutate(foo, bar)


    # loan_mut(foo, ref)
    # loan_mut(ref, foo)
    # mut_mut(foo, ref)
    # mut_mut(ref, foo)
}

# TODO List
# - For loop semantics
# - Support Fields (Probably use "path" approach Rust uses.)
# - Support upvalues (Code to support fields should support upvalues too.)
# - Support Arrays (Not sure what to do here.)


fn mut_mut(mut x: T, mut y: T) {}
fn loan_mut(x: T, mut y: T) {}
fn loan_loan(x: T, y: T) {}