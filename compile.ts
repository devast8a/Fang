import * as nearley from "nearley";
import chalk from "chalk";
import * as grammar from "./grammar";
import * as fs from "fs";

// Create a Parser object from our grammar.
const compiled = nearley.Grammar.fromCompiled(grammar);

function first(data){return data[0];}

for(const rule of compiled.rules){
    if(rule.name.indexOf('$') !== -1) {
        // Generated by nearley

        // Macro calls
        if(/\$macrocall\$\d+$/.test(rule.name)){
            if(rule.postprocess !== undefined){
                // Already has a post-processor assigned
            } else if(rule.symbols.length === 1) {
                rule.postprocess = first;
            }
        }
    } else if(rule.postprocess !== undefined){
        // Already has a post-processor assigned
    } else if(rule.symbols.length === 1) {
        rule.postprocess = first;
    }
}

const parser = new nearley.Parser(compiled);

class Source {
    public constructor(path: string, content: string){
        this.path = path;
        this.content = content;
    }

    public path: string;
    public content: string;
}

const path = process.argv[2];
const content = fs.readFileSync(path, "utf8");

const source = new Source(path, content);

parser.feed(source.content);

if(parser.results.length > 1){
    console.error("! AMBIGUOUS GRAMMAR !")
    console.log(parser.results.length);
}

enum Tag {
    Class,
    ExpressionCall,
    ExpressionConstruct,
    Function,
    Parameter,
    Trait,
}

type Expression =
    ExpressionCall |
    ExpressionConstruct;

type Type =
    Class |
    Trait |
    Function ;

class Function {
    public tag: Tag.Function = Tag.Function;
    public ast: any;

    public name: string;
    public parameters: Parameter[];
}

class Trait {
    public tag: Tag.Trait = Tag.Trait;
    public ast: any;

    public name: string;
}

class Class {
    public tag: Tag.Class = Tag.Class;
    public ast: any;

    public name: string;
    public traits: Set<Trait>;
}

class Parameter {
    public tag: Tag.Parameter = Tag.Parameter;
    public ast: any;
    
    public name: string | null;
    public type: Type;
}

class ExpressionCall {
    public tag: Tag.ExpressionCall = Tag.ExpressionCall;
    public ast: any;

    public target: Function;
    public arguments: Expression[];

    public resultType: Type;
}

class ExpressionConstruct {
    public tag: Tag.ExpressionConstruct = Tag.ExpressionConstruct;
    public ast: any;

    public target: Type;
    public arguments: Expression[];

    public resultType: Type;
}

const types = new Map<string, Type>();

function get_type({data}){
    const name = data[0].text;
    return types.has(name) ? types.get(name) : undefined;
}

function canConvertTo(a: Type, b: Type){
    if(a === b){
        return true;
    }

    if(b.tag === Tag.Trait){
        if(a.tag === Tag.Class){
            return a.traits.has(b);
        }
    }

    return false;
}

class CompilerError{
    public readonly heading: string;
    public readonly blamed: Expression[];

    public constructor(heading: string){
        this.heading = heading;
        this.blamed = [];
    }

    public blame(node: Expression) {
        this.blamed.push(node);
    }

    public display() {
        for(const blamed of this.blamed){
            const start = blamed.ast.target.offset;
            const end = blamed.ast.arguments.end.offset + 1;

            const str = source.content;

            let prefix = str.slice(0, start);
            const match = /\n[^\n]*\n[^\n]*\n[^\n]*$/.exec(prefix);
            prefix = str.slice(match.index + 1, start);

            let suffix = str.slice(end);
            if(suffix.indexOf('\n') !== -1){
                suffix = suffix.slice(0, suffix.indexOf('\n'));
            }

            let error = prefix + chalk.redBright(str.slice(start, end)) + suffix;
            error = error.replace(/\n/g, '\n> ');

            console.log('> ' + error);
            console.log(`[ERROR] The highlighted argument's type is not compatible with the parameter's type`);
        }
    }
}

function parse(node: any){
    switch(node.tag){
        case 'declare_trait': {
            const obj = new Trait();

            obj.ast = node.data;
            obj.name = node.data[1].text;

            types.set(obj.name, obj);
            return obj;
        }

        case 'declare_class': {
            const obj = new Class();

            obj.ast = node.data;
            obj.name = node.data[1].text;
            obj.traits = new Set;

            // Collect implemented traits
            for(const impl of node.data[2]){
                const type = get_type(impl[3]);

                if(type === undefined || type.tag !== Tag.Trait){
                    // TODO: Create better error handling system
                    throw new Error("Types can only impl trait")
                }

                obj.traits.add(type);
            }

            types.set(obj.name, obj);
            return obj;
        }

        case 'declare_function': {
            const obj = new Function();

            obj.ast = node.data;
            obj.name = node.data[1][0].text;

            // Collect parameters
            const parameters = [];
            for(const parameter of node.data[2].elements){
                const p = new Parameter();
                p.name = parameter.name === undefined ? null : parameter.name;

                const type = get_type(parameter.type);

                if(type === undefined){
                    // TODO: Create better error handling system
                    throw new Error("Type does not exist");
                }

                p.type = type;
                parameters.push(p);
            }
            obj.parameters = parameters;

            types.set(obj.name, obj);
            return obj;
        }

        case 'declare_extension': {
            const obj = types.get(node.target.name.text) as Class;

            // Collect implemented traits
            for(const impl of node.data[1].data[2]){
                const type = get_type(impl[3]);

                if(type === undefined || type.tag !== Tag.Trait){
                    // TODO: Create better error handling system
                    throw new Error("Types can only impl trait")
                }

                obj.traits.add(type);
            }

            break;
        }

        case 'expression_call': {
            const obj = new ExpressionCall();

            obj.ast = node.data;

            obj.target = types.get(node.target.text) as Function;
            obj.arguments = node.arguments.elements.map(parse);

            // TODO: Compute the result type of the expression
            // obj.resultType = obj.target;

            // TODO: Check if the types can be matched up
            if(obj.target.parameters.length !== obj.arguments.length){
                throw new Error("Not enough parameters");
            }

            const ps = obj.target.parameters;
            const as = obj.arguments;

            for(let i = 0; i < ps.length; i++){
                if(!canConvertTo(as[i].resultType, ps[i].type)){
                    const error = new CompilerError("Parameter has incorrect type");
                    error.blame(as[i]);
                    error.display();

                    process.exit(1);
                }
            }

            return obj;
        }

        case 'expression_construct': {
            const obj = new ExpressionConstruct();
            const args = node.arguments.elements.map(parse);

            obj.ast = node;

            obj.target = types.get(node.target.text);
            obj.arguments = args;

            obj.resultType = obj.target;

            return obj;
        }
    }
}

for(const node of parser.results[0]){
    parse(node);
}