import * as nearley from "nearley";
import chalk from "chalk";
import grammar from "./grammar";
import * as fs from "fs";
import { Tag as AstTag } from './post';
import { Thing, Type } from './ast';

// Create a Parser object from our grammar.
const compiled = nearley.Grammar.fromCompiled(grammar);

function first(data){return data[0];}

// Simplify our AST a bit. If our rule only has one thing it matches on,
//  don't create a new deeper set of nodes.
//
// Eg. Typically `foo -> bar bar; bar -> "A"`
//  would generate the ast [["A"], ["A"]] for the input "AA".
//  We decided to remove the extra layer of indirection, instead generating ["A", "A"]
for(const rule of compiled.rules){
    if(rule.name.indexOf('$') !== -1) {
        // Post-processors generated by Nearley rules.
        // We need to be careful about applying it to Nearley generated rules,
        //  otherwise we could break them - in particular rules that compact repetition into arrays

        // Macro calls
        if(/\$macrocall\$\d+$/.test(rule.name)){
            if(rule.postprocess !== undefined){
                // Already has a post-processor assigned
            } else if(rule.symbols.length === 1) {
                rule.postprocess = first;
            }
        }
    } else if(rule.postprocess !== undefined){
        // Already has a post-processor assigned
    } else if(rule.symbols.length === 1) {
        rule.postprocess = first;
    }
}

const parser = new nearley.Parser(compiled);

class Source {
    public constructor(path: string, content: string){
        this.path = path;
        this.content = content;
    }

    public path: string;
    public content: string;
}

export class Compiler {
    public types = new Map<string, Type>();

    public parse(node: any): Thing{
        switch(node.tag){
            // Run the AST builders on each Nearley node
            // See: ast_builders for the code that is actually run to build each AST Node
            // See: post for the code that wraps Nearley nodes with AST builders (in particular post.builder)
            case AstTag.NODE: {
                return node.builder(node.data, this);
            }

            // Ignore whitespace, this whitespace comes primarily from the whitespace between elements in statement lists.
            //  It should be removed much earlier in parsing, but we're waiting until we have a better idea how everything
            //  will pan out.
            case AstTag.WHITESPACE: {
                return;
            }

            default: {
                throw new Error(`Unknown node tag: ${node.tag}`);
            }
        }
    }

    public get_type(node: any){
        const name = node.data[0].text;
        return this.types.has(name) ? this.types.get(name) : undefined;
    }
};

const path = process.argv[2];
const content = fs.readFileSync(path, "utf8");

const source = new Source(path, content);

parser.feed(source.content);

if(parser.results.length > 1){
    console.error("! AMBIGUOUS GRAMMAR !")
} else {
    const state = new Compiler();
    for(const node of parser.results[0]){
        state.parse(node);
    }
}